
outputs: GP0 (bit 0), GP1 (bit 1), GP2 (bit 2), GP5 (bit 3) each display 1 bit of 4 bit output (#'s 0-15)

inputs: GP3 (start/stop roll), GP4 (mode selector)
	GP3: press to start roll, release to stop, display output (sum) on LEDs
	GP4: 0 = 2d8z (two, 8-sided dice [0000-0111]) [closed]
	GP4: 1 = 1d16z (one, 16-sided die [0000-1111]) [open]

*should expect even distribution of values for 1d16z, but lots of 6, 7, 8 relative to rest for 2d8z


subroutines:
	- allow mode selection (GP4)
	- wait for roll start (GP3) -> jump to selected mode routine (check bit)
	- while rolling, make LEDs sparkle, generate random numbers, wait for stop (GP3)
	- pull bottom 4 bits of lfsr (AND with 0Fh)
	- set output on GP(0/1/2/5) (rotate right and check carry)
	- save roll (circular buffer/bit masking)
		- use FSR (memory address), INDF (data)
		- mask top 4 bits (AND with 0x0F to keep just the bottom 6 bits, then OR with 0x10 bc start at 0x10)
			- this saves only the vales of 0x00 thru 0x0F, then essentially adds 0x10 to remain in values between 0x10 thru 0x1F
		- increment each roll


# FSR is not being set properly (just the listed value in Data Memory is wrong, but it works correctly despite showing incorrect values)

# When GP4 switch is closed/bit set to 0/in 2d8z mode, page will issue warning about program counter, but call still returns to the correct location and the program will execute correctly (bc used all 64 instructions)




